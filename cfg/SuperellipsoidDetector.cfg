#!/usr/bin/env python

PACKAGE="capsicum_superellipsoid_detector"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

enum_cost_type = gen.enum([
    gen.const("NAIVE", int_t, 0, "Uses the superellipsoid parametric representation directly."),
    gen.const("LEHNERT", int_t, 1, "Lehnerts implementation squares the parametric function value compared to Solinas method."),
    gen.const("RADIAL_EUCLIDIAN_DISTANCE", int_t, 2, "Works better with non-equilateral superellipsoids and estimates inside the shape better."),
    gen.const("SOLINA", int_t, 3, "Solinas distance approximation method with volume constraint. Estimates better for equilateral superellipsoids."),
    gen.const("SOLINA_DISTANCE", int_t, 4, "Solinas distance approximation method."),
    ],
    "Optimization Function"
)

enum_processing_mode = gen.enum([
    gen.const("PAUSED", int_t, -1, "Discards incoming data points."),
    gen.const("CONTINUOUS", int_t, 0, "Processes input continuously. position_threshold and orientation_threshold parameters may affect the processing."),
    gen.const("ON_REQUEST", int_t, 1, "Processes the NEXT input when the ProcessSingleMessage service is called. Can be also triggered with if position_threshold and orientation_threshold are set."),
    ],
    "Input Processing Mode"
)

# optimization
gen.add("cost_type", int_t, 0, "The cost function for fitting superellipsoids to the input points. RADIAL_EUCLIDIAN_DISTANCE and SOLINA are recommended options.", 2, 0, 4, edit_method=enum_cost_type)
gen.add("prior_center", double_t, 0, "The prior (alpha value in the formula) which enforcing optimized center **t** and center estimated via surface normals **p** to be close to each other. Higher values increases the regularization.", 0.1, 0, 1)
gen.add("prior_scaling", double_t, 0, "The prior (beta value in the formula) which is enforcing **a**, **b**, **c** values define the scaling of superellipsoid to be close to each other. Higher values increase the regularization. Different than the volume constraint.", 0.1, 0, 1)
gen.add("max_num_iterations", int_t, 0, "The maximum number of optimization iterations.", 100, 1, 1000)
gen.add("estimate_normals_search_radius", double_t, 0, "In meters. Search radius for surface normal estimation.", 0.015, 0.0001, 1.0)
gen.add("estimate_cluster_center_regularization", double_t, 0, "Regularization for the intersection of lines estimation. Defines a bias towards the mean of cluster points. Higher values bring the result towards the bias point. Useful when there are not enough surfaces.", 2.5, 0.0, 9999.0)

# clustering
gen.add("min_cluster_size", int_t, 0, "Discards clusters smaller than this value.", 100, 10, 1000)
gen.add("max_cluster_size", int_t, 0, "Discards clusters larger than this value.", 10000, 100, 1000000)
gen.add("cluster_tolerance", double_t, 0, "In meters. Groups two points with smaller distance than this value into the same cluster.", 0.01, 0.0001, 1.0)

# surface sampling
gen.add("use_fibonacci_sphere_projection_sampling", bool_t, 0, "If true, uses our approach for sampling of superellipsoid surfaces which distributes points on the surface uniformly. If false, uses the superellipsoid parametric representation which enables easier perceiving the orientation of the superellipsoids. This only affects the the output of **~superellipsoids_surface** message.", False)
gen.add("num_samples_fibonacci", int_t, 0, "todo", 1000, 10, 10000)
gen.add("u_res_parametric", double_t, 0, "In radians. Horizontal sampling interval of superellipsoid surface.", 0.05, 0.01, 0.5)
gen.add("v_res_parametric", double_t, 0, "In radians. Vertical sampling interval of superellipsoid surface.", 0.05, 0.01, 0.5)

# missing surfaces
gen.add("missing_surfaces_num_samples", int_t, 0, "The number of points being used to find points belonging to missing surfaces with rejection sampling.", 500, 10, 10000)
gen.add("missing_surfaces_threshold", double_t, 0, "In meters. Points sampled with the projected Fibonacci sphere method are compared to the input data points. If the distance is higher than the threshold, the point will be marked as a missing surface point.", 0.015, 0.001, 1.0)

# other parameters
gen.add("print_ceres_summary", bool_t, 0, "Enables printing cost, gradients, extra information, etc. for each optimization step.", False)
gen.add("world_frame", str_t, 0, "World transform frame.", "world")

# node-only parameters 
gen.add("processing_mode", int_t, 0, "Processing mode of the node. (Not used in the service)", 0, 0, 1, edit_method=enum_processing_mode)
gen.add("position_threshold", double_t, 0, "In meters. Positional movement threshold for triggering the superellipsoid detection. Set negative to disable.", -1.0, -1.0, 1.0)
gen.add("orientation_threshold", double_t, 0, "In radians. Orientational movement threshold for triggering the superellipsoid detection. Set negative to disable.", -1.0, -1.0, 3.14)
gen.add("pointcloud_volume_resolution", double_t, 0, "In meters. Resolution of the pointcloud in **~superellipsoids_volume** message.", 0.001, 0.001, 1.0)

# service-only parameters
# none...

exit(gen.generate(PACKAGE, "capsicum_superellipsoid_detector", "SuperellipsoidDetector"))
